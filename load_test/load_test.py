import time
import json
from datetime import datetime, timedelta
from typing import List, Dict
import matplotlib.pyplot as plt

from vldt_model_user import UserModel as UserModelVLDT
from pydantic_model_user import UserModel as UserModelPydantic

ITERATIONS = 100
NUM_RECORDS = 1000


def generate_fixed_user_dict(index: int) -> Dict:
    """
    Generate a fixed user dictionary with structured test data.

    Args:
        index (int): The index used to generate specific values.

    Returns:
        Dict: A dictionary representing a user's data with various attributes.
    """
    base_created = datetime(2025, 1, 1, 12, 0, 0)
    registered_at = (base_created + timedelta(hours=1, minutes=index)).isoformat()

    return {
        "id": index,
        "name": f"User_{index}",
        "age": (index % 50) + 18,
        "is_active": index % 2 == 0,
        "registered_at": registered_at,
        "address": {
            "street": f"Street_{index}",
            "city": f"City_{index % 10}",
            "postal_code": f"100{index % 100}",
        },
        "company": {
            "name": f"Company_{index}",
            "industry": f"Industry_{index % 5}",
            "employees": (index % 100) + 10,
        },
        "profile": {
            "username": f"user{index}",
            "email": f"user{index}@example.com",
            "bio": f"Bio for user {index}" if index % 2 == 0 else None,
            "website": f"https://website{index}.com" if index % 3 == 0 else None,
        },
        "bank_account": {
            "account_number": f"ACC{index:06d}",
            "balance": round((index % 500) * 1.5, 2),
            "transactions": [
                {"amount": round((i % 20) * 3.14, 2)} for i in range((index % 5) + 1)
            ],
        },
        "preferences": {
            "theme": "dark" if index % 2 == 0 else "light",
            "language": ["en", "es", "fr", "de"][index % 4],
            "notifications_enabled": index % 3 != 0,
        },
        "scores": [i * 2 for i in range((index % 10) + 1)],
        "attributes": {
            f"key_{i}": f"value_{index % 10}" for i in range((index % 5) + 1)
        },
        "security_level": (index % 5) + 1,
        "friends": [f"Friend_{i}" for i in range((index % 4) + 1)],
        "metadata": {
            f"meta_key_{i}": {f"sub_key_{j}": f"value_{index % 10}" for j in range(2)}
            for i in range((index % 3) + 1)
        },
        "tags": [f"tag_{i}" for i in range((index % 5) + 1)],
        "rating": round((index % 100) / 20.0, 2),
        "phone_number": f"+12345678{index % 1000}",
        "additional_info": {
            f"info_{i}": f"extra_{index}" for i in range((index % 3) + 1)
        },
        "bonus": float(index % 10),
        "score_multiplier": float(index % 3 + 1),
        "level": index % 100,
    }


def get_test_dicts() -> List[Dict]:
    """
    Generate a list of user dictionaries for testing.

    Returns:
        List[Dict]: A list of dictionaries generated by `generate_fixed_user_dict`.
    """
    return [generate_fixed_user_dict(i) for i in range(1, NUM_RECORDS + 1)]


def get_test_json_strings() -> List[str]:
    """
    Generate a list of JSON strings representing user data for testing.

    Returns:
        List[str]: A list of JSON strings generated from user dictionaries.
    """
    dicts = get_test_dicts()
    return [json.dumps(d) for d in dicts]


def run_tests() -> Dict[str, Dict[str, float]]:
    """
    Run performance tests comparing VLDT and Pydantic model operations.

    This function tests:
      1. Parsing from dict to model instance.
      2. Dumping model instance to dict.
      3. Parsing from JSON to model instance.
      4. Dumping model instance to JSON.
      5. Appending model instances to a list.
      6. Mixed usage operations including parsing and dumping.

    Returns:
        Dict[str, Dict[str, float]]: A dictionary of test operation results with timings for VLDT and Pydantic.
    """
    results = {}
    dict_data = get_test_dicts()
    json_strings = get_test_json_strings()

    start = time.perf_counter()
    for _ in range(ITERATIONS):
        for data in dict_data:
            _ = UserModelVLDT(**data)
    vldt_parse_dict = time.perf_counter() - start

    start = time.perf_counter()
    for _ in range(ITERATIONS):
        for data in dict_data:
            _ = UserModelPydantic(**data)
    pydantic_parse_dict = time.perf_counter() - start
    results["Parse Dict"] = {"vldt": vldt_parse_dict, "pydantic": pydantic_parse_dict}

    vldt_instances = [UserModelVLDT(**data) for data in dict_data]
    pydantic_instances = [UserModelPydantic(**data) for data in dict_data]

    start = time.perf_counter()
    for _ in range(ITERATIONS):
        for instance in vldt_instances:
            _ = instance.to_dict()
    vldt_dump_dict = time.perf_counter() - start

    start = time.perf_counter()
    for _ in range(ITERATIONS):
        for instance in pydantic_instances:
            _ = instance.model_dump()
    pydantic_dump_dict = time.perf_counter() - start
    results["Dump Dict"] = {"vldt": vldt_dump_dict, "pydantic": pydantic_dump_dict}

    start = time.perf_counter()
    for _ in range(ITERATIONS):
        for js in json_strings:
            _ = UserModelVLDT.from_json(js)
    vldt_parse_json = time.perf_counter() - start

    start = time.perf_counter()
    for _ in range(ITERATIONS):
        for js in json_strings:
            _ = UserModelPydantic.model_validate_json(js)
    pydantic_parse_json = time.perf_counter() - start
    results["Parse JSON"] = {"vldt": vldt_parse_json, "pydantic": pydantic_parse_json}

    start = time.perf_counter()
    for _ in range(ITERATIONS):
        for instance in vldt_instances:
            _ = instance.to_json()
    vldt_dump_json = time.perf_counter() - start

    start = time.perf_counter()
    for _ in range(ITERATIONS):
        for instance in pydantic_instances:
            _ = instance.model_dump_json()
    pydantic_dump_json = time.perf_counter() - start
    results["Dump JSON"] = {"vldt": vldt_dump_json, "pydantic": pydantic_dump_json}

    start = time.perf_counter()
    instances = []
    for _ in range(ITERATIONS):
        for data in dict_data:
            instance = UserModelVLDT(**data)
            instances.append(instance)
    vldt_append_list = time.perf_counter() - start

    start = time.perf_counter()
    instances = []
    for _ in range(ITERATIONS):
        for data in dict_data:
            instance = UserModelPydantic(**data)
            instances.append(instance)
    pydantic_append_list = time.perf_counter() - start
    results["Append To List"] = {
        "vldt": vldt_append_list,
        "pydantic": pydantic_append_list,
    }

    start = time.perf_counter()
    vldt_mixed = []
    for _ in range(ITERATIONS):
        for data, js in zip(dict_data, json_strings):
            instance = UserModelVLDT(**data)
            _ = instance.to_dict()
            _ = UserModelVLDT.from_json(js)
            _ = instance.to_json()
            vldt_mixed.append(instance)
    vldt_mixed_time = time.perf_counter() - start

    start = time.perf_counter()
    pydantic_mixed = []
    for _ in range(ITERATIONS):
        for data, js in zip(dict_data, json_strings):
            instance = UserModelPydantic(**data)
            _ = instance.model_dump()
            _ = UserModelPydantic.model_validate_json(js)
            _ = instance.model_dump_json()
            pydantic_mixed.append(instance)
    pydantic_mixed_time = time.perf_counter() - start
    results["Mixed Usage"] = {"vldt": vldt_mixed_time, "pydantic": pydantic_mixed_time}

    header = f"{'Operation':<25} {'vldt (s)':<13} {'pydantic (s)':<13}"
    sep = "-" * len(header)
    print(header)
    print(sep)
    for op, times in results.items():
        print(f"{op:<25} {times['vldt']:<13.6f} {times['pydantic']:<13.6f}")

    return results


def generate_consolidated_chart(results: Dict[str, Dict[str, float]]):
    """
    Generate and save a consolidated bar chart comparing performance timings.

    Args:
        results (Dict[str, Dict[str, float]]): A dictionary containing operation names as keys and dictionaries
            with 'vldt' and 'pydantic' timings as values.
    """
    operations = list(results.keys())
    vldt_times = [results[op]["vldt"] for op in operations]
    pydantic_times = [results[op]["pydantic"] for op in operations]

    x = range(len(operations))
    width = 0.35

    plt.figure(figsize=(10, 6))
    plt.bar([i - width / 2 for i in x], vldt_times, width=width, label="vldt")
    plt.bar([i + width / 2 for i in x], pydantic_times, width=width, label="pydantic")
    plt.xticks(x, operations, rotation=45)
    plt.ylabel("Time (s)")
    plt.title("Performance Comparison: VLDT vs. Pydantic (Lower is Better)")
    plt.legend()
    plt.tight_layout()
    plt.savefig("assets/performance_chart.png")
    print("Consolidated chart saved as performance_chart.png")
    plt.close()


if __name__ == "__main__":
    """
    Main entry point for running tests and generating a performance chart.
    """
    results = run_tests()
    generate_consolidated_chart(results)
